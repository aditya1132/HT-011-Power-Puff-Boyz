import asyncio
import logging
import time
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple

import google.generativeai as genai
from google.generativeai.types import HarmBlockThreshold, HarmCategory

from app.core.config import get_settings
from app.core.exceptions import AIServiceError

logger = logging.getLogger(__name__)
settings = get_settings()


class GeminiService:
    """Google Gemini AI service for mental health companion"""

    def __init__(self):
        """Initialize Gemini service with configuration"""
        self.api_key = settings.GEMINI_API_KEY
        self.model_name = settings.GEMINI_MODEL
        self.temperature = settings.GEMINI_TEMPERATURE
        self.max_tokens = settings.GEMINI_MAX_TOKENS
        self.enabled = settings.GEMINI_ENABLED

        if self.enabled and self.api_key:
            try:
                genai.configure(api_key=self.api_key)
                self.model = genai.GenerativeModel(
                    model_name=self.model_name,
                    generation_config=genai.types.GenerationConfig(
                        temperature=self.temperature,
                        max_output_tokens=self.max_tokens,
                        top_p=0.8,
                        top_k=10,
                    ),
                    safety_settings={
                        HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                        HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                        HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                        HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_LOW_AND_ABOVE,
                    },
                )
                logger.info(f"Gemini service initialized with model: {self.model_name}")
            except Exception as e:
                logger.error(f"Failed to initialize Gemini service: {e}")
                self.enabled = False
                self.model = None
        else:
            self.model = None
            logger.warning(
                "Gemini service disabled - API key not provided or service disabled"
            )

    def is_available(self) -> bool:
        """Check if Gemini service is available"""
        return self.enabled and self.model is not None and self.api_key is not None

    async def generate_empathetic_response(
        self,
        user_message: str,
        detected_emotion: str,
        emotion_intensity: float,
        context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Generate empathetic response using Gemini

        Args:
            user_message: User's input message
            detected_emotion: Detected emotion (e.g., "anxious", "sad")
            emotion_intensity: Emotion intensity (0.0 to 1.0)
            context: Additional context about the user

        Returns:
            Dict containing response and metadata
        """
        if not self.is_available():
            raise AIServiceError("Gemini service is not available")

        try:
            prompt = self._build_empathy_prompt(
                user_message, detected_emotion, emotion_intensity, context
            )

            start_time = time.time()
            response = await asyncio.to_thread(self.model.generate_content, prompt)
            processing_time = (time.time() - start_time) * 1000

            if response.candidates and response.candidates[0].content.parts:
                response_text = response.candidates[0].content.parts[0].text.strip()

                # Validate response appropriateness
                if self._is_response_appropriate(response_text, user_message):
                    return {
                        "message": response_text,
                        "source": "gemini",
                        "processing_time_ms": processing_time,
                        "safety_ratings": self._extract_safety_ratings(response),
                        "finish_reason": response.candidates[0].finish_reason
                        if response.candidates
                        else None,
                    }
                else:
                    raise AIServiceError("Generated response failed safety validation")
            else:
                raise AIServiceError("No valid response generated by Gemini")

        except Exception as e:
            logger.error(f"Gemini response generation failed: {e}")
            raise AIServiceError(f"Failed to generate Gemini response: {str(e)}")

    async def analyze_emotion_with_gemini(self, user_message: str) -> Dict[str, Any]:
        """
        Analyze emotions using Gemini

        Args:
            user_message: User's input message

        Returns:
            Dict containing emotion analysis
        """
        if not self.is_available():
            raise AIServiceError("Gemini service is not available")

        try:
            prompt = self._build_emotion_analysis_prompt(user_message)

            start_time = time.time()
            response = await asyncio.to_thread(self.model.generate_content, prompt)
            processing_time = (time.time() - start_time) * 1000

            if response.candidates and response.candidates[0].content.parts:
                response_text = response.candidates[0].content.parts[0].text.strip()
                emotion_data = self._parse_emotion_response(response_text)
                emotion_data["processing_time_ms"] = processing_time
                emotion_data["source"] = "gemini"
                return emotion_data
            else:
                raise AIServiceError("No valid emotion analysis generated")

        except Exception as e:
            logger.error(f"Gemini emotion analysis failed: {e}")
            raise AIServiceError(f"Failed to analyze emotions with Gemini: {str(e)}")

    async def get_coping_suggestions(
        self,
        emotion: str,
        intensity: float,
        user_context: Optional[Dict[str, Any]] = None,
    ) -> List[str]:
        """
        Get personalized coping suggestions using Gemini

        Args:
            emotion: Detected emotion
            intensity: Emotion intensity
            user_context: Additional context

        Returns:
            List of coping suggestions
        """
        if not self.is_available():
            raise AIServiceError("Gemini service is not available")

        try:
            prompt = self._build_coping_prompt(emotion, intensity, user_context)

            response = await asyncio.to_thread(self.model.generate_content, prompt)

            if response.candidates and response.candidates[0].content.parts:
                response_text = response.candidates[0].content.parts[0].text.strip()
                suggestions = self._parse_coping_suggestions(response_text)
                return suggestions
            else:
                return []

        except Exception as e:
            logger.error(f"Gemini coping suggestions failed: {e}")
            return []

    def _build_empathy_prompt(
        self,
        user_message: str,
        emotion: str,
        intensity: float,
        context: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Build prompt for empathetic response generation"""

        intensity_desc = (
            "very intense"
            if intensity > 0.8
            else "intense"
            if intensity > 0.6
            else "moderate"
            if intensity > 0.4
            else "mild"
        )

        base_prompt = f"""You are an empathetic AI mental health companion designed to provide supportive, non-judgmental responses. Your role is to:

1. Validate the person's feelings without minimizing them
2. Provide gentle, supportive responses
3. Suggest healthy coping strategies when appropriate
4. Encourage professional help for serious concerns
5. Never provide medical advice or diagnosis

User's message: "{user_message}"
Detected emotion: {emotion} ({intensity_desc} intensity)

Guidelines for your response:
- Be warm, empathetic, and validating
- Keep responses concise (2-4 sentences)
- Use "I" statements to show understanding ("I can hear that...")
- Avoid toxic positivity or dismissing concerns
- If the person expresses crisis thoughts, prioritize safety resources
- Focus on the person's strengths and resilience
- Suggest one specific, actionable coping strategy if appropriate

Context: {context if context else "First interaction"}

Respond as a caring, professional mental health companion:"""

        return base_prompt

    def _build_emotion_analysis_prompt(self, user_message: str) -> str:
        """Build prompt for emotion analysis"""

        return f"""Analyze the emotional content of this message and provide a structured response.

Message: "{user_message}"

Please analyze and respond in this exact format:
PRIMARY_EMOTION: [one of: anxious, sad, angry, stressed, overwhelmed, lonely, grateful, happy, excited, neutral]
INTENSITY: [number from 0.0 to 1.0]
SECONDARY_EMOTIONS: [comma-separated list of up to 2 additional emotions if present]
CRISIS_INDICATORS: [yes/no - if the message contains concerning language about self-harm or suicide]
CONFIDENCE: [number from 0.0 to 1.0 indicating confidence in the analysis]

Focus on identifying the most prominent emotion and any signs that might indicate the person needs immediate support."""

    def _build_coping_prompt(
        self, emotion: str, intensity: float, context: Optional[Dict[str, Any]] = None
    ) -> str:
        """Build prompt for coping suggestions"""

        return f"""Suggest 3 specific, evidence-based coping strategies for someone experiencing {emotion} at {intensity:.1f} intensity.

Context: {context if context else "General situation"}

Please provide practical, actionable suggestions that:
1. Can be done immediately or within a few minutes
2. Are evidence-based (mindfulness, CBT, breathing, grounding, etc.)
3. Are appropriate for the emotion and intensity level
4. Don't require special equipment or extensive preparation

Format your response as a simple numbered list:
1. [Strategy 1]
2. [Strategy 2]
3. [Strategy 3]

Keep each suggestion to one clear sentence."""

    def _parse_emotion_response(self, response_text: str) -> Dict[str, Any]:
        """Parse structured emotion analysis response"""
        emotion_data = {
            "primary_emotion": "neutral",
            "intensity": 0.5,
            "secondary_emotions": [],
            "crisis_indicators": False,
            "confidence": 0.5,
        }

        try:
            lines = response_text.split("\n")
            for line in lines:
                line = line.strip()
                if line.startswith("PRIMARY_EMOTION:"):
                    emotion_data["primary_emotion"] = (
                        line.split(":", 1)[1].strip().lower()
                    )
                elif line.startswith("INTENSITY:"):
                    try:
                        emotion_data["intensity"] = float(line.split(":", 1)[1].strip())
                    except ValueError:
                        pass
                elif line.startswith("SECONDARY_EMOTIONS:"):
                    emotions = line.split(":", 1)[1].strip()
                    if emotions and emotions != "none":
                        emotion_data["secondary_emotions"] = [
                            e.strip().lower() for e in emotions.split(",")
                        ]
                elif line.startswith("CRISIS_INDICATORS:"):
                    emotion_data["crisis_indicators"] = (
                        line.split(":", 1)[1].strip().lower() == "yes"
                    )
                elif line.startswith("CONFIDENCE:"):
                    try:
                        emotion_data["confidence"] = float(
                            line.split(":", 1)[1].strip()
                        )
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to parse emotion response: {e}")

        return emotion_data

    def _parse_coping_suggestions(self, response_text: str) -> List[str]:
        """Parse coping suggestions from response"""
        suggestions = []

        try:
            lines = response_text.split("\n")
            for line in lines:
                line = line.strip()
                if line and (
                    line[0].isdigit() or line.startswith("-") or line.startswith("•")
                ):
                    # Remove numbering and clean up
                    suggestion = line.lstrip("0123456789.-• ").strip()
                    if suggestion and len(suggestion) > 10:  # Minimum length check
                        suggestions.append(suggestion)
        except Exception as e:
            logger.warning(f"Failed to parse coping suggestions: {e}")

        return suggestions[:3]  # Limit to 3 suggestions

    def _is_response_appropriate(self, response: str, original_message: str) -> bool:
        """Validate response appropriateness for mental health context"""

        # Check for inappropriate content
        inappropriate_phrases = [
            "just think positive",
            "get over it",
            "it could be worse",
            "just relax",
            "stop being so dramatic",
            "you're overreacting",
            "snap out of it",
            "others have it worse",
        ]

        response_lower = response.lower()
        for phrase in inappropriate_phrases:
            if phrase in response_lower:
                logger.warning(f"Response contains inappropriate phrase: {phrase}")
                return False

        # Check minimum quality standards
        if len(response.strip()) < 20:
            return False

        if (
            response.count(".") == 0
            and response.count("!") == 0
            and response.count("?") == 0
        ):
            return False  # Should have some punctuation

        return True

    def _extract_safety_ratings(self, response) -> Dict[str, str]:
        """Extract safety ratings from Gemini response"""
        safety_ratings = {}

        try:
            if hasattr(response, "candidates") and response.candidates:
                candidate = response.candidates[0]
                if hasattr(candidate, "safety_ratings"):
                    for rating in candidate.safety_ratings:
                        category = (
                            rating.category.name
                            if hasattr(rating.category, "name")
                            else str(rating.category)
                        )
                        probability = (
                            rating.probability.name
                            if hasattr(rating.probability, "name")
                            else str(rating.probability)
                        )
                        safety_ratings[category] = probability
        except Exception as e:
            logger.warning(f"Failed to extract safety ratings: {e}")

        return safety_ratings

    async def health_check(self) -> Dict[str, Any]:
        """Check if Gemini service is healthy"""
        if not self.is_available():
            return {
                "status": "unavailable",
                "message": "Gemini service not configured or disabled",
            }

        try:
            # Simple test request
            test_response = await asyncio.to_thread(
                self.model.generate_content,
                "Respond with exactly: 'Service is working'",
            )

            if test_response.candidates and test_response.candidates[0].content.parts:
                response_text = (
                    test_response.candidates[0].content.parts[0].text.strip()
                )
                return {
                    "status": "healthy",
                    "message": "Gemini service is operational",
                    "model": self.model_name,
                    "test_response": response_text,
                }
            else:
                return {
                    "status": "error",
                    "message": "Gemini service returned no response",
                }
        except Exception as e:
            logger.error(f"Gemini health check failed: {e}")
            return {"status": "error", "message": f"Gemini service error: {str(e)}"}


# Global instance
gemini_service = GeminiService()
